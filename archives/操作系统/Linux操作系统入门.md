## Linux操作系统入门

为什么每一台计算机第一个需要安装的软件就是操作系统？操作系统的作用是什么呢？

你可以把操作系统理解成一个**公司的老板，协调硬件资源（输入输出设备、CPU、内存、磁盘、网卡、显卡），完成客户的项目（进程）。**

![img](https://i.loli.net/2021/10/02/B4nMo1p7CZw9kVQ.jpg)

- 操作系统：老板
- 系统调用：办事大厅（项目必须通过系统调用请求资源）
- 进程管理子系统：项目管理系统（负责每个项目的创建和管理）
- 内存管理子系统：会议室（每个项目都要有自己独立的内存空间）
- 文件子系统：项目档案管理
- 输入输出设备：与项目对接交付人员（客户通过输入传递请求，通过输出得到结果）
- 网络子系统：对外合作（与其他项目的交互）

![img](https://static001.geekbang.org/resource/image/21/f5/21a9afd64b05cf1ffc87b74515d1d4f5.jpeg)

## 快速上手几个命令

- 更改当前用户密码
  - passwd
- 创建新用户
  - useradd
- 看得懂ls -l
  - https://time.geekbang.org/column/article/88761
- 查看安装的所有软件
  - rpm -qa
  - rpm -qa | grep jdk    利用管道搜索过滤想要的软件
  - dpkg -l

## 快速上手几个系统调用

![img](https://i.loli.net/2021/10/03/oKaI7xVSfkBgCdN.jpg)

## 文件系统

- 如何查看文件的权限

## 进程管理

### 进程调度策略

在 Linux 里面，进程大概可以分成两种。

一种称为实时进程，也就是需要尽快执行返回结果的那种。这就好比我们是一家公司，接到的客户项目需求就会有很多种。有些客户的项目需求比较急，比如一定要在一两个月内完成的这种，客户会加急加钱，那这种客户的优先级就会比较高。

另一种是普通进程，大部分的进程其实都是这种。这就好比，大部分客户的项目都是普通的需求，可以按照正常流程完成，优先级就没实时进程这么高，但是人家肯定也有确定的交付日期。

每个进程都有一个优先级参数，实时进程优先级为0 ~ 99，普通进程优先级为100 ~ 139	，越低优先级越高。

不同进程调度策略不同

- 实时进程
  - FIFO: 相同优先级进程先来先得
  - RR: 轮流调度策略, 采用时间片轮流调度相同优先级进程
  - Deadline: 在调度时, 选择 deadline 最近的进程

- 普通进程

## 内存管理

- 虚拟内存和物理内存

  - 概念
  - 映射方法：分段式和分页式

- 分段式

  - 每个进程都被分为四段：代码分段、数据分段、栈段、堆段组成。

  - 通过虚拟内存中的段号和段表（起始地址和偏移量）把虚拟地址映射到物理地址
  - 缺点是会产生大量内存碎片，且内存换出换回时效率低，因为每段的内存大小都很大

- 分页式

  - 缺页异常：虚拟内存的页号在页表找不到
  - 把虚拟内存和物理内存分成一个个页，每个页的大小为4kb。通过页号和页表（物理页号+偏移量）把虚拟内存映射到物理内存
  - 单级分页下，32位系统下每个进程的虚拟内存为4gb，可以分成10^6个页，在页表中每页的大小为4字节，因此每个进程需要的页表大小为4mb。如果有100个进程的话，就需要消耗100mb的内存来保存页表。这样明显不合理，所以有了多级页表
  - 32位适用的二级页表：1024一级页表*1024二级页面。一级页面必加载，二级页面需要时再加载。因此每个进程最小需要的页表内存为4kb，是一个巨大的提升

- 段页式

- 虚拟内存布局

- 物理内存布局

## 文件系统

首先要明确的是：linux把硬盘分成若干个块（block），每个块的默认大小为4k。如果存放一个文件，这个文件会被分散成若干个块进行存储，读取文件时根据 inode 的信息找到目标块读取数据。

inode即文件 node 的索引，每个文件都会有自己的inode，用来维护“有几个块，每个块存放在哪”的基本信息，此外还有其他信息如创建时间、修改时间、权限等

```C

struct ext4_inode {
  __le16  i_mode;    /* File mode */
  __le16  i_uid;    /* Low 16 bits of Owner Uid */
  __le32  i_size_lo;  /* Size in bytes */
  __le32  i_atime;  /* Access time */
  __le32  i_ctime;  /* Inode Change time */
  __le32  i_mtime;  /* Modification time */
  __le32  i_dtime;  /* Deletion Time */
  __le16  i_gid;    /* Low 16 bits of Group Id */
  __le16  i_links_count;  /* Links count */
  __le32  i_blocks_lo;  /* Blocks count */
  __le32  i_flags;  /* File flags */
......
  __le32  i_block[EXT4_N_BLOCKS];/* Pointers to blocks !!!就是这里*/
  __le32  i_generation;  /* File version (for NFS) */
  __le32  i_file_acl_lo;  /* File ACL */
  __le32  i_size_high;
......
};
```

iblock就是维护“有几个块，每个块存放在哪”。它的结构如下：

![img](https://static001.geekbang.org/resource/image/73/e2/73349c0fab1a92d4e1ae0c684cfe06e2.jpeg)

是一个数组，前12项保存了每个块的地址，可以通过索引下标访问到每个块。后三项为间接块，也是索引块，是为了防止文件过大12个块无法存储的情况

### 硬链接

- 作用：我们知道每个文件都有一个inode，存储文件的其他附属数据。在Linux文件系统中，多个文件名可以指向同一个Inode节点是正常允许的，这种情况的文件就被称之为硬链接文件，硬链接的作用之一就是**允许一个文件拥有多个有效的访问入口，如果创建了一个硬链接文件，我把源文件给删除了，但是数据还没丢，因为硬链接文件还存在，删除的只是文件名，工作中比较重要的文件可以做硬链接。**文件系统(ext2)的原理是，只要文件的索引节点（Inode）还有一个以上的硬链接，只删除其中一个硬链接（即仅仅删除了该文件的链接指向）并不影响索引节点本身和其他的链接（即数据文件实体并未被删除），只有当文件的最后一个链接被删除后，此时如果有新数据要存储到硬盘上或者系统通过类似fsck做磁盘检查的时候。被删除文件的数据块及目录的链接才会被释放，空间新数据占用并覆盖，此时，数据再也无法找回了。也就是说，在Linux系统中，删除静态文件（没有进程调用）（目录也是文件）的条件是与之相关的所有硬链接文件均被删除。

- 通过命令 `ln 源文件 目标文件` 可以创建硬连接

  ```SHELL
  ln /root/zyl_code/my_python3.7/ls_test/111 111_link #创建硬连接
  ```

- 通过rm可以删除硬链接文件
- 目录不可以创建硬链接

### 软连接

- 作用：软连接相当于Windows的快捷方式，Linux里面软连接实际上就是一个特殊的文件，里面存放的是原文件的路径，指向源文件实体，它的inode和源文件不同。删除源文件软连接依旧存在，只是没有任何意义了，会导致软连接失效。
- 通过命令 `ln -s 源文件 目标文件` 可以创建软连接
- 通过rm可以删除软连接文件
- 目录可以创建软连接

## 进程间通信

### 管道

管道是进程间通信的一种方式，是单向通信，一段写一端读，因此实现进程间的相互通信需要两道管道。

```SHELL
ps -ef | grep java
```

这条命令就使用到了管道机制，“ | ”创建了一个匿名管道，匿名管道随着命令的执行自动创建、自动销毁。

使用命令 `mkfifo`可以创建命名管道，管道也是一个文件，以p开头，pipe 

```shell
mkfifo hello
echo "hellopipe" > hello
cat < hello

- 创建管道、写、读
```

### 消息队列

和java中的消息队列差不多，每个消息队列都是一个文件，因此要先创建一个文件，使用函数msgget创建消息队列（绑定文件inode和队列），使用msgsnd发送消息，使用msgrcv接受消息

### 共享内存模型

就是每个进程都有一块虚拟地址映射到相同的物理地址，这样其他进程修改该物理地址的数据就能被实时看到，不需要复制来复制去

- 使用shmget创建共享内存对象
- 使用shmah加载共享内存

### 信号量

- semget创建信号量
- semop操作信号量（P操作和V操作）

### 信号机制



