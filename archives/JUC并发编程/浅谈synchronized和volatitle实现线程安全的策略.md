# 浅谈synchronized和volatitle实现线程安全的策略

## 什么是线程不安全

我对线程安全的理解就是多个线程同时操作一个共享变量时会产生意料之外的情况，这种情况就是线程不安全。注意：只有写操作才可能出现线程不安全，对共享变量只进行读操作线程是绝对安全的。

具体线程不安全的例子有一个很经典的就是两个线程都对一个共享变量x=0执行100次自增操作，但是x的结果并非200

**因此线程不安全的条件是：多线程 + 共享变量 + 写操作**

## Java的内存模型

你可能会好奇线程是如何获取共享变量的，这就为你解答

Java线程之间的通信由Java内存模型（简称JMM）控制，从抽象的角度来说，JMM定义了线程和主内存之间的抽象关系。JMM的抽象示意图如图所示：

<img src="https://i.loli.net/2021/04/17/mOsLVUrfEl7bt3k.png" alt="image-20210417162759801" style="zoom:150%;" />

从图中我们可以看到：

- 共享变量存在于主内存中，也就是堆内存
- 每一个线程都保存了一份该线程使用到的**共享变量的副本**
- 线程读取共享变量优先从本地内存(也就是栈内存)中读取，写共享变量先写到栈内存，再写入堆内存
- 线程之间对共享变量的通信只能通过堆内存

以上只是Java内存模型的抽象图，实际上线程的工作模型是这样的，栈内存即是两个缓冲区

![image-20210417163527051](https://i.loli.net/2021/04/17/HTJ3YNydovAbC6u.png)

接下来看一个线程不安全的例子：

假设线程A、B操作同一个共享变量X，初始两级Cache都为空

1. 线程A想要读取X的值，由于两级Cache都没有命中，因此加载堆内存中的X=0，并缓存到两个Cache中
2. 线程A修改X的值为1，为为两个Cache刷新X，再刷新到堆内存
3. 线程B想要获取X的值，一级缓存没有获取到，二级缓存命中，读取到X=1
4. 线程B想要修改X的值为2，先刷新自，己的一级缓存为2，再刷新二级缓存和堆内存中的X为2。目前为止一切正常，接下来重点来了
5. 线程A想要读取X的值，一级缓存命中此时X=1，但是堆内存中的X=2。可以看到线程B写入的共享变量对X不可见，出现了线程不安全的情况。

由于Java内存机制就是这样设计的，因此多个线程操作同一个变量会产生不安全的问题，volatitle关键字这是被设计出来解决这一问题的，它**只能用于单个变量**。

## volatile解决共享变量线程不安全的策略

还是接着上面这个例子，我们这样定义X

`volatle int X=0`

**volatile的内存语义是：**

当一个线程对`volatile `修饰的变量进行写操作时，JMM会立即将该线程对应的栈内存中的副本的值刷新到堆内存中；**当一个线程对`volatile `修饰的变量进行读时，JMM会清空此变量的一二级缓存，直接从堆内存中读取共享变量的值。**

`volatile`可以当作一个轻量级的锁来使用，但`volatile`仅仅只能保证共享变量内存的可见性，不能保证操作共享变量的原子性，而锁（如`synchronized`）能保证整段锁范围内的代码具有原子性。

## synchronized与锁
首先要明确的是`synchronized`不是锁，锁都是基于对象的(Object的子类)，Java中的每一个对象都可以作为一个锁。

`synchronized`是Java的一个关键字，保证临界区内的代码同一时刻只能有一个线程执行。

线程的执行代码在进入`synchronized`代码块前会自动获取内部锁，这时候其他线程访问该同步代码块时会被阻塞挂起。拿到内部锁的线程会在**正常退出同步代码块**或者**抛出异常**后或者**在同步块内调用了该内置锁资源的wait**系列方法时释放该内置锁。内置锁是排它锁，也就是当一个线程获取这个锁后，其他线程必须等待该线程释放锁后才能获取该锁。

> sysnchronized的内部锁可以是：
>
> - 当前类的class字节码对象：this.getClass
> - 当前类的一个实例：this
> - 一个Object对象
>
> wait和notify方法只能用于synchronized同步代码块内

## synchronized的内存语义

与`volatile`不同

进入`synchronized`块的内存语义是把再`synchronized`块内使用到的所有共享变量从栈内存中清空，这样就只能从堆内存只读取，保证了内存可见性。退出synchronized块的内存语义是把`synchronized`块内对共享变量的修改刷新到堆内存。

仔细想想，这其实也是一个加锁和解锁的过程，保证共享变量修改的可见性。

## 总结

- `volatile`仅能保证**单个共享变量**内存的可见性，不能保证原子性。而synchronized既可保证**同步块内所有共享变量**的内存可见性，又能保证其操作的原子性。

- `volatile`是一个轻量级的保证内存可见性的关键字，实际上并没有加锁。因此它的性能很高。
- `synchronized`是一个重量级的锁，可以用在代码块、普通方法以及静态方法上。用在代码块时锁就是`synchronized(~)`内的对象，用在普通方法时锁就是`this`,用在静态方法时锁就是`this.getClass()`
- `synchronized`保证同步块内代码的原子性，因为要进行线程上下文切换，性能较低。不过优化过后性能也还可以。

## 参考

- [深入浅出Java多线程](https://redspider.gitbook.io/concurrent/di-er-pian-yuan-li-pian/8)
- Java并发编程之美


















