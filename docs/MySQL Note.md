### MySQL Note

思维导图(敖丙)👇：https://www.processon.com/view/5e86b713e4b0bf3ebcf4e376#outline

> Mysql面试题目：
>
> https://blog.nowcoder.net/n/477a70139a34447589b6f3186f04550b
>
> https://ld246.com/article/1583601362044/comment/1584005099680

#### 1. Mysql的日志系统

MySQL日志的作用是什么？这是一个很关键的问题。虽然一直在用，但是以前我对日志这个东西一直处于有点懵懵懂懂的状态，知道它有用，但是具体什么用处却说不上来。直到我看了丁奇老师的专栏。下面来说说我的理解。

MySQL日志的主要作用有两个：

- 帮助我们对数据库进行备份和恢复。当数据库异常时，根据日志的记录，我们可以把

  mysql还原到15天前任何一个状态(完全依赖binlog归档日志实现)

- Debug

MySQL有两个主要的日志模块，Serve层的binlog日志，以及InnoDB存储引擎特有的redo log日志。以下所有关于日志的介绍都是基于InnoDB引擎。

- redo log日志又叫物理日志，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存。InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，即是追加写。Redo log不是记录数据页“更新之后的状态”，而是记录这个页 “做了什么改动”。
- bin log日志又叫逻辑日志。有两种模式，statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有。

#### 2. Mysql的逻辑架构

1. 👨‍⚖️：一条sql语句在mysql中如何执行的？  

   🙋‍♂️：回答这个问题前需要先聊一聊mysql的逻辑架构[具体看拓展知识]

   SQL语句分为查询和更新。

   ==先看查询==

   `select * from tb_student  A where A.age='18' and A.name=' 张三 ';`

   - 查看**是否有权限**。有的话在 MySQL8.0 版本以前，会先查询缓存，以这条 sql 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。
   - 词法分析+语法分析，得到要执行的sql语句(知道它要干嘛)
   - 优化器优化，得到最终要执行的优化完的sql语句(最终的sql)

   - **再次校验权限**。如果有权限就会调用数据库存储引擎接口，返回引擎的执行结果。

   ==更新语句==

   MySQL更新记录的原理是WAL，先写日志，再写磁盘。这样既能提高效率，又能保证安全(crash safe)。即使数据库挂了，之前的提交记录依旧不会丢。

   `update tb_student set age=age+1 where id=2;`
   
   更新语句执行的流程和查询语句差不多，也会把下面的流程走一遍
   
   - 查询缓存，因为更新语句会清空缓存，所以直接下一步
   - 分析器+优化器得知这是一条更新语句，且使用id这个索引
   - InnoDB将这个记录写入到redo log中(磁盘)，此时这个语句就算执行结束，redo log处于prepare状态。之后InnoDB会在适当的时候把记录更新到数据库磁盘中
   - 执行器生成这个操作的binlog，把binlog写入磁盘
   - InnoDB把redo log状态更新为commit
   
   <img src="https://i.loli.net/2021/04/02/fYrOlId4Fyuomhi.png" style="zoom:200%;" />

> 拓展知识：
>
> ==mysql逻辑架构图==
>
> ![](https://i.loli.net/2021/03/31/WJuYkhliE5nUgP1.png)
>
> Mysql主要分为Server层和存储引擎层。
>
> - **Server 层**：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。
>   - 连接器：`mysql -u root -p 123456`,连接到mysql后会从权限表查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即时管理员修改了该用户的权限，该用户也是不受影响的。
>   - 查询缓存：执行select查询语句后首先查询缓存(key-value形式，判断该sql是否已经被执行过)。MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常写的数据来说，使用缓存还是可以的。
>   - 分析器：词法分析+语法分析。分析sql语句是用来干嘛的。如果sql错误，会`“You have an error in your SQL syntax”` 的错误提醒
>   - 优化器：选择它认为的最优的执行方案去执行。比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。
>   - 执行器：根据权限表中定义的存储引擎，去使用这个存储引擎提供的接口。比如我们的例子中，表 T 中，ID 字段没有索引，那么执行器的流程是：
>     1. 调用 InnoDB 存储引擎接口取一行，判断 `ID=10`。如果不是，则跳过；如是，则保存到结果集中。
>     2. 然后再取下一行，重复直到表结束为止。
>     3. 最后组成结果集返回给客户端。
>
> - **存储引擎：**主要负责数据的存储和读取，采用可以**替换的插件式架构**，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。**现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。**

2. 👨‍⚖️：为什么redo log要两阶段提交？

   🙋‍♂️：主要是为了保证redo log和bin log的逻辑一致性。

   ​		  如果只有一次提交，先当写完redo log日志时数据库崩溃了，bin log没写到，但是数据库的记录已经修改了。之后使用bin log进行备份或者恢复时就会出现错误。同杨的，先写完bin log后数据库崩溃了，redo log还没来得及写，数据库中的记录并没有更新，但是bin log却以为它已经更新了，同样会出现不同步的错误。

   ​	     因此，正确的逻辑是：

   - redo log提交后数据库崩溃，bin blog还没来得及写，重启后发现redo log还是prepare状态，此时redo log和bin log逻辑不一致。redo log回滚，相当于先前操作没有执行。
   - bin log写完后崩溃，redo log还没commit。重启后发现bin log有数据，把redo log状态修改完commit，此时redo log和bin log逻辑一致，先前操作算数。

3. 👨‍⚖️：如果要进行备份和恢复的话，似乎redo log就可以完成这个任务，为什么还需要bin log？

   🙋‍♂️：bin log还不能去掉。一个原因是，redolog只有InnoDB有，别的引擎没有。另一个原因是，redolog是循环写的，不持久保存，binlog是新增写，binlog的“归档”这个功能，redolog是不具备的。

#### 3. MySQL的事务篇

[/03讲事务隔离：为什么你改了我还看不见]: file:///C:/Documents/Learning/MySQL45%E8%AE%B2/03%E8%AE%B2%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E6%88%91%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81.html

> 基础知识：
>
> - ACID
> - 多个事务同时运行时出现的问题 
> - 事务的隔离级别

1. 👨‍⚖️：读未提交、读已提交、可重复读和串行化的实现原理：

   🙋‍♂️：在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读已提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。

   > <img src="https://i.loli.net/2021/04/09/1jO9nzb564eiNmd.png" alt="image-20210403094038344" style="zoom:150%;" />
   >
   > 可以使用`show variables like 'transaction_isolation'`来查看当前数据的隔离级别。
   >
   > <img src="https://i.loli.net/2021/04/09/CyPSp2VYRWTbg6m.png" alt="image-20210403094309353" style="zoom: 200%;" />
   >
   > 修改当前隔离级别

2. 👨‍⚖️：事务隔离是怎么实现的？

   🙋‍♂️：每条记录在更新的时候都会同时记录一条回滚操作（记录在回滚日志中undo）。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。

3. 👨‍⚖️：为什么尽量不要使用长事务？

   🙋‍♂️：<img src="https://i.loli.net/2021/04/09/X5uQC8OwibEdaFl.png" alt="image-20210403095310113" style="zoom:500%;" />
   

#### 4. MySQL的索引篇

> 基础知识：
>
> - Mysql索引是什么？有什么用？
>
>   索引实际上相当于字典的目录，可以帮助你快速找到目的记录。比如现在有一个sql语句`select * from student where id=100`。如何数据库没有id这个字段的索引，就需要进行暴力遍历，时间复杂度为O(N)。但是如果数据库有id这个字段的索引，查询数据就能快得多。比如InnoDB存储引擎索引使用的底层数据结构是B+树，查找此条记录只需要2~3次查询。
>
>   当然索引也不是越多越好，维护索引需要花费一定的精力。因此不能为所有字段都建立索引，一般我们只给常用的字段生成索引。
>
> - Mysql索引的底层数据结构
>
>   [MySQL底层数据结构]: https://zhuanlan.zhihu.com/p/113917726
>
>   Mysql索引底层可选的数据结构有哈希表、数组、二叉树和N叉树等。其中哈希表不适合用于范围查询，数组更新时间复杂度大，二叉树(包括红黑树和二叉平衡树)会退化成链表或者近似链表，且每次只能查询一条记录，以上三种有各自的缺点，不适合用于索引的底层数据结构。
>
>   考虑到我们数据库的数据不止要存在于内存，还要存在于磁盘，而磁盘读取一条记录花费的时间和读取多条记录花费的时间差不多，因此我们需要每次查询尽可能多的数据。
>
>   因此InnoDB选择的数据结构是B+树，每一个索引在InnoDB里代表一颗B+树。
>
> - 主键索引和普通索引
>
>   InnoDB的索引可以分为主键索引和普通索引。主键索引的叶节点存放的是整个记录的数据，而普通索引的叶节点存放的是此条记录的主键。一张表只能有一个主键索引，普通索引可以有多个。
>
>   
>
> - InnoDB中数据页的概念

1. 👨‍⚖️：基于主键索引和普通索引的查询有什么区别？

   🙋‍♂️：如果语句是`select * from student where id=100`,即主键索引查询方式，则只需要搜素一颗B+树。

   ​		  如果语句是`select * from student where name='zhangsan'`，即普通索引查询方式，则需要搜索name这颗B+树得到id，再搜索id这颗B+树得到整条记录，这个过程叫做回表。

   ​		  因此我们要尽量使用主键查询。

2. 👨‍⚖️：为什么我们经常建议每个表都要使用自增主键？

   🙋‍♂️：这和索引数据页的添加方式有关

3. 👨‍⚖️：讲一下覆盖索引

   🙋‍♂️：如果执行的语句是`select id from student where age between 13 and 15`，这时只需要查id的值，而id(主键)的值已经在age索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引age已经“覆盖了”我们的查询需求，我们称为覆盖索引。

   ​	      由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。

4. 👨‍⚖️：讲一下联合索引

   🙋‍♂️：联合索引即是由多个字段组成的一条索引，联合索引的目的就是为了提高存在多个查询条件的情况下的效率。如果现在有一个高频请求：有一张学生表，根据学号查找姓名，这个时候为学号字段和姓名字段建立一个联合索引(学号,姓名)就很有必要了

   ​	  	如果有这样一条SQL`select * from student where stu=1 and name=‘zhangsan’`。根据最左前缀匹配原则，在联合索引B+树上找到学号为1的记录，判断name是否为‘张三’。如果不是直接跳过不回表，如果是回表查询整条记录。这也叫做==索引下推==。**索引下推可以减少回表的次数。**如果没有索引下推，每一个stu=1都要回表。

   ​		  总结：联合索引其实就是(普通索引)覆盖索引的升级版本。可以把普通索引看作该字段和主键的联合索引。sql语句是否使用联合索引依赖的是最左匹配原则：根据创建联合索引的顺序，以最左原则进行where检索，比如（age，name）以age=1 或 age= 1 and name=‘张三’可以使用索引，单以name=‘张三’ 不会使用索引，考虑到存储空间的问题，还请根据业务需求，**将查找频繁的数据进行靠左创建索引**。

   > 创建索引的技巧
   >
   > ![image-20210404153402481](https://i.loli.net/2021/04/09/iDahT6w39S4bGJt.png)

5. 👨‍⚖️：Mysql如何为字段添加索引？

   🙋‍♂️：![image-20210404153532222](https://i.loli.net/2021/04/09/wTK5zeF9dLYrCb2.png)


#### 5. MySQL的各种锁

多线程并发操作数据库时后引起脏读、幻读和不可重复读等，要想避免这些问题，就必须对共享资源(数据库、表、行)加锁。

其实所有的锁都是为了保证==只能同时读，不能同时写==

Mysql的锁有全局锁、表级锁和行级锁。

> - 全局锁：顾名思义，就是对整个数据库加锁，让数据库处于只读状态，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。常用于全库逻辑备份。
>
>   但是让整个库都处于只读听上去就很危险。如果主库备份，回导致业务停摆，如果从库备份，会导致从库无法同步binlog，主从延迟。
>
> - 表级锁：对某张表加锁。
>
>   - 表锁
>
>     语法是`lock tables t1 read, t2 write`;那么该线程只能读t1，写t2。其他线程只能读t1，不能读写r2
>
>   - MDL锁
>
>     默认的锁，任何一个线程访问表都会在这张表加上MDL锁。
>
>     在MySQL 5.5版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。
>
> - 行级锁(InnoDB支持，MyISAM不支持)：对某个记录加锁，可以同时读，不能同时写
>
>   在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。知道了这个设定，如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。

1. 👨‍🎓：如何安全的给小表加字段？

   🙋‍♂️：这涉及到MDL锁的机制。修改表的结构需要先获取表的写锁，对表crud的操作需要获取表的读锁，写锁释放之前是获取不到读锁的。因此要想安全的给表添加字段，比较理想的机制是，在alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。

   此外，还要解决长事务的问题。因为MDL锁的释放是事务提交后再释放，如果长事务不提交，会一直占用MDL读锁，导致写锁无法获取。

2. 👨‍🎓：MySQL是如何解决死锁问题的？
3. 🙋‍♂️：发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。

   

   