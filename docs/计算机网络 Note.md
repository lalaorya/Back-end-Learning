[TOC]

参考自小林coding👇：

> 面经分享：
>
> http://blog.beifengtz.com/article/44#directory0423187831916922919
>
> https://www.iamshuaidi.com/673.html

#### 1. Http协议

> 常见面试题：
>
> ![image-20210405091651519](https://i.loli.net/2021/04/05/cOZSCqVaynJDUkw.png)

1. 状态码

   <img src="https://i.loli.net/2021/04/15/vHpZhYaV8jURoA6.png" alt="image-20210405092727263" style="zoom: 50%;" />

2. 字段

   <img src="https://i.loli.net/2021/04/15/fkVNItlneKwOcQD.png" alt="image-20210405101626472" style="zoom:50%;" />

   <img src="https://i.loli.net/2021/04/05/ldpnVCusyRmMXJB.png" alt="image-20210405101759644" style="zoom:50%;" />

   <img src="https://i.loli.net/2021/04/05/xeH27rbLFpIhcAQ.png" alt="image-20210405101811383" style="zoom:50%;" />

   <img src="https://i.loli.net/2021/04/05/QXGLz9JAENWfUFP.png" alt="image-20210405101841272" style="zoom:50%;" />

3. GET和POST的区别

   - Get：从服务器获取资源，安全且幂等
   - Post：提交资源给服务器，不安全不幂等

   > 幂等：多次执行结果一致

4. Http1.1的优点(相比1.0)和缺点

   ==优点==

   - 简单、灵活易于扩展和应用广泛跨平台

   - 长连接，keep-alive字段。长连接的特点是只要任意一方没有断开连接，则保持TCP连接状态。

     > 早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销.为了解决上述 TCP 连接问题，HTTP/1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。

   - 管道运输。由于使用了长连接，可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间

   ==缺点==

   - 无状态。Http没有记忆能力，通常需要依赖cookie实现关联操作
   - 明文传输。信息很容易被抓取。
   - **不安全**(**最大的缺点，因此催生了Https，在tcp层和http层加了ssl/tls安全协议，保证安全**)
     - 通信使用明文（不加密），内容可能会被窃听。比如，账号信息容易泄漏，那你号没了。
     - 不验证通信方的身份，因此有可能遭遇伪装。比如，访问假的淘宝、拼多多，那你钱没了。
     - 无法证明报文的完整性，所以有可能已遭篡改。比如，网页上植入垃圾广告，视觉污染，眼没了。

#### 2. HTTP和HTTPS

##### ①  HTTP和HTTPS的区别

> 1. HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
> 2. HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
> 3. HTTP 的端口号是 80，HTTPS 的端口号是 443。
> 4. HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

##### ② HTTPS是怎么保证安全的？

> - 窃听风险 → 对明文进行混合加密
> - 冒充风险 → 数字证书
> - 篡改风险 → 摘要算法，生成独一无二的指纹

1. 混合加密

   <img src="https://i.loli.net/2021/04/15/P6NRjcxsGFOk1nT.png" alt="image-20210405113824543" style="zoom:67%;" />
   
   **通信前使用公钥私钥进行会话密钥的共享。之后都使用会话密钥进行传输。**
   
   > 必备基础知识
   >
   > - 公钥
   >
   > - 私钥
   >
   >  公钥私钥是成对的。公钥可以给任何人，私钥只能自己保存。公钥私钥之间可以互相解密。
   >
   >   公钥私钥一般有两个用法，公钥加密私钥解密和私钥加密公钥验证。
   >
   >    a. 使用公钥对明文进行加密，只有私钥才能解密。
   >
   >    b. 使用私钥对信息进行加密，所有人的公钥都可以解密。因此私钥加密一般用于验证这个信息真的来自私钥，不可告人的信息不能使用私钥进行加密，因为所有人都可以解密。
   >
   > - 对称加密
   > - 非对称加密
   >
   > 对称加密只有一个私钥，也叫会话密钥。加密和解密都是用这个私钥。
   >
   > 非对称加密就是上面说的公钥私钥，公钥加密私钥解密，私钥加密公钥验证。
   >
   > 对称加密的优点是效率高，缺点是私钥共享时不安全，可能会被别人窃取了你的私钥。
   >
   > 非对称加密的优点是安全，十分安全，缺点是效率低，一般只用于少量信息的加密。
   >
   > - 混合加密
   >
   > 混合加密结合了对称加密和非对称加密。
   >
   > 对称加密的痛点是会话密钥的传输不安全，因此我们可以使用非对称加密对会话密钥进行加密共享，以后的信息传输都使用会话密钥。这样既保证了安全，有提交了效率。
   
2. 数字证书 

   ![image-20210405114114966](https://i.loli.net/2021/04/15/BaZet5VmuSsryA1.png)

   也就是说要想使用HTTPS，就需要去CA申请数字证书。客户端（公钥）识别服务器响应信息真伪的关键就是看数据证书（私钥）是否真实。这样就避免伪造信息。

3. 摘要算法

   ![image-20210405114428979](https://i.loli.net/2021/04/15/shOrc1jaI3imLXf.png)

##### ③ HTTPS是如何连接的？

##### SSL/TLS 协议基本流程：

- 客户端向服务器索要并验证服务器的公钥

  > 服务器
  >
  > - 公钥：自身的数字签名
  > - 数字证书：CA的私钥对服务器公钥加密生成数字证书
  >
  > 验证公钥：使用CA的公钥验证数字证书，看看是否是HTTPS

- 双方协商生产「会话秘钥」

- 双方采用「会话秘钥」进行加密通信

#### 3. 输入网址后发生了什么？

- 解析url，生成http请求报文

- DNS域名解析：查询服务器域名对应的IP地址

  > <img src="https://i.loli.net/2021/04/15/bCc4OMNHS3mR6LB.png" alt="image-20210406174344305" style="zoom:80%;" />
  >
  > 本地DNS服务器，找不到本地DNS服务器请求根服务器。根服务器告诉找谁(顶级域名 -> 一级域名 -> 二级域名)。查找到IP地址后返回给本地DNS，本地DNS响应给浏览器。

- Http报文封装成TCP报文，与服务器建立TCP连接(三次握手)。如果报文太长，会被拆成多个TCP报文。

  > ![image-20210406222407968](https://i.loli.net/2021/04/15/4cPmuJSk6yUCGI7.png)
  >
  > 带了个"头盔"😅

- tcp报文封装成IP数据报(根据路由表确定目的IP地址:直接交付还是默认网关)。IP数据报继续封装成数据帧(使用ARP协议确定MAC地址)。
- 通过网卡把数据帧的数字信号转化为电信号，通过网线发出去
- 通过交换机在同一个网络中进行传输，通过路由器在不同网络间传输。目的都是为了根据IP地址找到目标服务器，这个过程MAC地址一直在变，IP地址始终不变。
- 服务器收到数据包后，开始一层一层扒皮，取出Http报文信息。之后把响应的Http报文响应回浏览器，浏览器进行渲染。通信结束。

==一些常用命令：==

- netstat -nap		查看当前设备的TCP连接状态
- route -n         查看当前设备的路由表
- arp -a        查看当前设备的arp缓存表

#### 4. IP协议相关技术

- DNS：通过域名查询IP地址

- ARP：通过IP地址查询MAC地址

  > 向本网络发送ARP广播报文

- DHCP：动态主机配置协议

  > DHCP使用**UDP**协议，服务端的端口为`67`，客户端的端口为`68`。
  >
  > 作用：
  >
  > - 用于内部网络或网络服务供应商自动分配IP地址给用户。
  > - 用于内部网络管理员作为对所有电脑作中央管理的手段。

- NAT（NAPT）

  > NAT：私有地址转化为公有地址，没有端口，需要多个公网IP
  >
  > NAPT：私有地址+端口号转化为公有地址，因此只需要一个公网IP
  >
  > ![image-20210509225915997](https://i.loli.net/2021/05/13/ZGz9frKc61ViWBn.png)

- ICMP：互联网控制报文协议。用来确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。

  > ![image-20210509230605019](https://i.loli.net/2021/05/13/ofcI4GdCnzEUNsD.png)
  >
  > ![image-20210509230619700](https://i.loli.net/2021/05/13/XNpZFxYgWJQuMl6.png)

- IGMP

#### 5. TCP篇

> 常见面试题：
>
> ![image-20210510102140520](https://i.loli.net/2021/05/13/5vFRWXnPJLGIoe8.png)
>
> ![image-20210510102154303](https://i.loli.net/2021/05/12/LuclpK7Dw1AkPQU.png)
>
> ![image-20210510102221770](https://i.loli.net/2021/05/12/iJvwYMIX8NWD43p.png)
>
> ![image-20210510102234208](https://i.loli.net/2021/05/12/IySb5vlmR3dMP18.png)
>
> ![image-20210511092744140](https://i.loli.net/2021/05/12/871IR3dE2zAq9eo.png)

##### 1. 有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？

最大 TCP 连接数 m = 客户端 IP 数 * 客户端端口数

对于 IPV4 而言   m = $2^{32}$  * $2^{16}$

当然，服务端最大并发 TCP 连接数远不能达到理论上限。首先主要是文件描述符限制，Socket 都是文件，所以首先要通过ulimit配置文件描述符的数目；另一个是内存限制，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的。

##### 2. TCP和UDP的区别

- ==TCP 是面向连接的传输层协议，传输数据前先要建立连接。==
- ==UDP 是不需要连接，即刻传输数据。==
- TCP 是一对一的两点服务，即一条连接只有两个端点。
- UDP 支持一对一、一对多、多对多的交互通信
- ==TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达==
- ==UDP 是尽最大努力交付，不保证可靠交付数据。==
- TCP 有拥塞控制和流量控制机制，保证数据传输的安全性
- UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率
- ==TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是20个字节，如果使用了「选项」字段则会变长的==
- ==UDP 首部只有 8 个字节，并且是固定不变的，开销较小==
- TCP 是流式传输，没有边界，但保证顺序和可靠。
- UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序
- ==TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片==
- ==UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了一个分片，则就需要重传所有的数据包，这样传输效率非常差，所以通常 UDP 的报文应该小于 MTU==

我的总结

TCP和UPD的本质区别就是一个是可靠的、一个是不可靠的。

可靠：数据一定无差错、不丢失、不重复、按序到达

不可靠：只能保证到达的数据一定正确，但是可能会有丢失、重复、乱序

我们知道IP协议是不可靠的，尽最大努力交付，TCP就是设计来保证可靠性的。我们看看他是如何实现的

- 单播模式
- **滑动窗口**

- .....

##### 3. 为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？

原因是 TCP 有可变长的「选项」字段，而 UDP 头部长度则是不会变化的，无需多一个字段去记录UDP 的首部长度。

##### 4. 三次握手

![image-20210511092548110](https://i.loli.net/2021/05/12/KUB7xvLCywjoQc8.png)

- 服务器监听某个端口，处于 Listen 状态

- 客户端随机生成序列号，序列号和确认应答号是TCP实现可靠的关键。向服务器发送SYN报文（SYN标志位置为1，表示这是一个同步报文），该报文不包含应用层数据。之后客户端处于 SYN-SENT 状体

- 服务器收到 SYN 报文后，也随机生成自己的序号，向客户端发送 SYN + ACK 报文，让客户端同步自己的序列号并且告诉客户端自己已经收到了它的报文，下一次发送SYN+1，该报文同样不包含应用层数据。之后服务器处于 SYN-RCVD 状态

  > SYN + ACK 报文可以分两次发送，这样就是四次握手，不过没必要，一起发送即可。
  >
  > ![image-20210511093434559](https://i.loli.net/2021/05/12/PSfFpQ7dqbwNJAa.png)

- 客户端收到服务器报文后，还要向服务器回应最后一个ACK报文，表示自己应该同步了它的序列号。确认应该号为服务器序列号+1。该报文可以携带数据，携带的序列号为收到服务器报文的应答号。之后客户端处于 ESTABLISHED 状态

- 服务器收到客户端应该报文后，也处于 ESTABLISHED 状态

- 三次握手成功，TCP连接建立

  > 其实三次握手就是为了同步客户端服务器双方的序列号，为后续滑动窗口协议实现可靠性做准备

##### 5. 为什么一定是三次握手呢？四次握手或者两次握手可以吗？

先说答案，四次握手可以，但没必要，两次握手不可以。

先从三个方面来分析三次握手的原因：

- 避免重复历史连接初始化造成混乱以及资源的浪费

  > ![image-20210511095146631](https://i.loli.net/2021/05/12/YcQtdUD6OsrnjWA.png)
  >
  > 网络是错综复杂的，如果客户端向服务器发送一个SYN同步报文，由于网络原因超时，客户端就会重新初始化序列号并重新发送一个SYN同步报文。但是如果第一个报文的ACK报文恰好在此时到达客户端 ,客户端通过上下文比较发送ACK报文的确认序列号和自己期望收到的序列号不一致，知道这是一个历史报文，因此立即发送RST报文给服务器中止这个连接。这样就避免了历史连接带来的混乱。
  >
  > 但是如果是二次握手：
  >
  > 对于服务器而言，每收到收到SYN同步报文后立即进入ENABLE状态，建立一个TCP连接。如果客户端的SYN阻塞了，重复发送多次SYN报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。
  >
  > 对于客户端而言，收到服务器的SYN+ACK 报文，无法判断当前连接是否属于历史连接
  >
  > 但是如果是三次握手的话，既能避免资源浪费，又能避免历史连接带来的混乱
  >
  > - 如果是历史连接（序列号过期或超时），则第三次握手发送的报文是RST报文，以此中止历史连接
  > - 如果不是历史连接，则第三次发送的报是ACK报文，通信双方就会成功建立连接

- 同步通信双方序列号

  > TCP 协议的通信双方，都必须维护一个「序列号」，序列号是可靠传输的一个关键因素，它的作用：
  >
  > - 接收方可以去除重复的数据；
  > - 接收方可以根据数据包的序列号按序接收；
  > - 可以标识发送出去的数据包中，哪些是已经被对方收到的；
  >
  > 只有三次握手才能同步双发序列号，一次服务器收到客户端序号，二次服务器告知客户端自己已经同步了它的序列号，三次客户端告知服务器自己也已经同步了它的序列号。
  >
  > 当然四次握手也能同步序列号，但是二次握手不行

##### 6. 初始序列号 ISN 是如何随机产生的？

起始ISN是基于时钟的，每 4 毫秒 + 1，转一圈要 4.55 个小时。

RFC1948 中提出了一个较好的初始化序列号 ISN 随机生成算法。

ISN = M + F (localhost, localport, remotehost, remoteport)

- M是一个计时器，这个计时器每隔 4 毫秒加 1。 
- F是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。

##### 7. SYN攻击

我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的SYN报文，服务端每接收到一个SYN报文，就进入SYN_RCVD状态，但服务端发送出去的ACK + SYN报文，无法得到未知 IP 主机的ACK应答，久而久之就会占满服务端的 SYN 接收队列（未连接队列），使得服务器不能为正常用户服务。

##### 8. 四次挥手

![image-20210511103622515](https://i.loli.net/2021/05/12/69u3RQqtgr8ZikM.png)

- 客户端向服务器发送 FIN 报文，表示客户端不再发送数据但是还能接收数据
- 服务器先回一个 ACK 应答报文，因为服务器可能还需要处于一些数据
- 等服务器不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接（因此ACK 和 FIN 报文需要分开发送，从而比三次握手多了一次）
- 客户端发送ACK报文，服务器接收到后进入CLOSE状态，客户端需要等 2MSL 时间后，自动进入 CLOSE 状态
- 至此，四次挥手完成，TCP连接关闭

##### 9. 为什么需要等待2MSL（或者说为什么需要TIME_WAIT状态）？

- 防止旧连接的数据包

  > 假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后会发生什么呢？
  >
  > ![image-20210511110516733](https://i.loli.net/2021/05/12/loT4eq1tOZA82xb.png)
  >
  > 可以看到旧的报文有可能会被新的TCP连接接收
  >
  > 因此TCP就设置了这么个机制，经过 2MSL 时间，足以让这次连接的数据包都被丢弃，再出现的数据包一定是新连接产生的

- 保证服务端连接正常关闭

  > 假如客户端第四次握手的ACK报文在网络中丢失，由于没有收到最后的ACK报文，服务器将无法正常关闭。因此设置2MSL 时间的另一个原因是为了服务器端重发FIN并等待客户端新的ACK报文，保证服务端正常关闭

##### 10. TIME_WAIT等待时间为什么是2MSL？

MSL是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

比如如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 Fin 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方，一来一去正好 2 个 MSL。

2MSL的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么2MSL 时间将重新计时

#### 6. Socket编程

#### 7. “可靠”的TCP是如何实现的？

##### 1. 重传机制

针对丢失的数据报，TCP有四种重传机制来保证数据包不丢失且按需到达

- 超时重传

  在发送数据时，设定一个定时器，当超过指定的时间后，**没有收到对方的ACK确认应答报文**，就会重发该数据，也就是我们常说的超时重传。无论是请求数据包丢失还是响应数据包丢失，都会触发重传机制。

  <img src="https://i.loli.net/2021/05/13/gE28dve314WNh7S.png" alt="image-20210513161236435" style="zoom: 200%;" />

  ==超时重传机制的关键是确定重传时间RTO，一般情况下 RTO 要略大于 RTT（数据包的往返时间）==

  - 如果 RTO >> RTT，那么丢失了很久才会被发现，重传慢，效率低
  - 如果 RTO << RTT，那么导致可能并没有丢就重发，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。

  RTT 和 RTO 的时间都是随网络情况动态变化的，具体怎么算这里不深入讨论

- 快速重传
  
  第二种重传机制是快速重传，原理是只有收到三个同样的ACK（确认序列号）就重传
  
  ![image-20210513162254179](https://i.loli.net/2021/05/27/TIvE89OuYzjtBgV.png)
  
  如上图，Seq2丢失了，Seq3、Seq4、Seq5成功到达接受方，接收方回应三个响应报文，确认应答号都是 ACK2，表示 Seq1 我已经收到了，给我 Seq2。发送方收到三个同样的ACK2，就知道 Seq2 丢了，于是重发Seq2
  
  但是还有一个问题，因为发送方不知道这三个 ACK 是谁发的，因此是只重发 Seq2，还是 Seq2 以下的都要重发呢？两种情况都有可能，我们接着往下看
  
- SACK 选择性确认

  这是对快速重传机制的优化，旨在解决上面那个问题

  在每个TCP报文的头部的 可变 字段加一个 SACK 的东西，它可以将本方缓存的地图发送给发送方，这样发送方就知道哪些数据收到了，哪些数据没收到，**只重传丢失的数据**

  ![image-20210513163048815](https://i.loli.net/2021/05/27/NLF7D5uofZcG3xE.png)

- D-SACK 重复-选择性确认

  同样使用 SACK 来告诉发送方有哪些数据被重复接收了

  使用 D-SACK 的好处有：

  - 可以让发送方知道是发出去的包丢了，还是接收方回应的 ACK 包丢了;
  -  可以知道是不是「发送方」的数据包被网络延迟了

##### 2. 滑动窗口

通常情况下为了保证可靠传输，发送方每发送一次数据都要等待接收方进行确认应答，以此来保证数据包完整、按需、不丢失。

![image-20210515210852632](https://i.loli.net/2021/05/15/TOLhzr7Yx8JEZd4.png)

但是很明显，通信的效率太低了。因此又引入了滑动窗口的概念，

**滑动窗口大小就是指无需等待应答可以继续发送数据的最大值，滑动窗口只针对发送方，接收方是没有滑动窗口概念的。**

窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。

![image-20210515211230437](https://i.loli.net/2021/05/27/A4UrDb3FVjqxP7n.png)

随着滑动窗口还引入了一个累计应答的概念。比如只有发送方受到了ACK700 的应答报文，就说明 700 之前的都收到了。

TCP的头部有一个字段为 滑动窗口大小，用来控制对方的窗口大小，为什么是对方呢？这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。

##### 3. 流量控制

##### 4. 拥塞控制



   