参考：

> - [万字图文 | 聊一聊 ReentrantLock 和 AQS 那点事（看完不会你找我）](https://xie.infoq.cn/article/8c8de2eab6cf13a5d922d0491)
> - [02_可重入锁(递归锁)+LockSupport+AQS源码分析](https://blog.csdn.net/TZ845195485/article/details/109210263)
> - [尚硅谷Java大厂面试题全集(java面试，周阳主讲)-Java面试_大厂高频面试题_阳哥](https://www.bilibili.com/video/BV1zb411M7NQ?p=147)

## AQS是什么？

AQS（AbstractQueuedSynchronizer），即抽象同步队列。JUC中常用锁、同步器、信号量的底层都是使用AQS实现的，是一个抽象框架，我们也可以继承AQS抽象类重写抽象方法实现我们自己的锁/同步器，但是一般没有人那么干。

我对AQS的理解：因为多线程编程，多个线程争抢一个共享资源，肯定会有人没抢到，没抢到的就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制就是使用AQS来实现的。通常我们把没抢到的线程需要推到一个队列（CLH队列）里面，等锁释放后再优先安排队首的线程(非公平锁不一定是安排队首）。

## AQS的底层实现

## 以ReentrantLock为例分析AQS的源码





很难写，太费时间了 说一下具体思路和我对AQS的总结以及面试常问的把。详细的源码分析以后再写。

> 总结:
>
> - AQS=变体的CLH队列+volatile int state变量表示该共享资源的状态。使用CAS操作来改变state的状态
> - CLH队列使用双向链表实现，使用head和tail变量表示队列头和队列尾
> - 入队的不是Thread对象，而是被封装成一个Node队列，Node的属性有Thread和watiStatus，此线程和等待的状态。
> - ReentrantLock抢占资源的过程
>   - 调用tryacquire方法，判断能够抢占到该锁(state能否由0变1)
>   - 如果不能调用addwaiter方法把Node结点放到等待队列。队列中的第一个结点是哨兵结点，空结点，第二个开始才是我们的结点。Head指向空结点，Tail指向我们的最后一个结点
>   - 接下来调用acquireQueued方法，看看等待队列中有没有能够抢占成功的，一般情况下是没有。因此把该线程阻塞（调用的是park），不要让它一直搁那自旋，浪费资源。等锁被释放了，才唤醒阻塞的线程，它又开始自旋，此时情况不一样了，锁被释放了，它成功抢到。当前队首变哨兵了，哨兵没人指向它被回收了
>
> 附：
>
> 如果是公平锁抢占的方式会有点不一样，多了一个判定条件，就是队列中没有等待线程它才会去枪，有的话只能乖乖排队了。

